package net.waymire.tyranny.common;

import java.security.MessageDigest;

import net.waymire.tyranny.common.util.Digest;

/**
 * Challenge Handshake Authentication Protocol (CHAP) is a widely supported authentication method.
 * With CHAP, the remote access server sends a challenge to the remote access client. The remote 
 * access client uses a hash algorithm (also known as a hash function) to compute a Message Digest-5 
 * (MD5) hash result based on the challenge and a hash result computed from the user's password. 
 * The remote access client sends the MD5 hash result to the remote access server. The remote 
 * access server, which also has access to the hash result of the user's password, performs the 
 * same calculation using the hash algorithm and compares the result to the one sent by the client. 
 * If the results match, the credentials of the remote access client are considered authentic
 * 
 * @author Chris Waymire <cwaymire@apriva.com>
 *
 */
public class CHAP
{
	private byte[] challenge = null;
	private byte[] proof = null;
	private String secret = null;
	
	/**
	 * Set the value of the secret.
	 * 
	 * The secret is a value known to both participants whether
	 * it is a shared key or a users password. This value will
	 * be hashed with the challenge to produce an array of bytes
	 * that will be transferred across the wire.
	 * 
	 * @param secret		the shared secret
	 */
	public synchronized void setSecret(String secret)
	{
		this.secret = secret;
	}
	
	/**
	 * Return the value of the secret.
	 * 
	 * The secret is a value known to both participants whether
	 * it is a shared key or a users password. This value will
	 * be hashed with the challenge to produce an array of bytes
	 * that will be transferred across the wire.
	 * 
	 * @return				the shared secret
	 */
	public synchronized String getSecret()
	{
		return secret;
	}
	
	/**
	 * Set the value of the challenge.
	 * 
	 * The challenge is an array of bytes generated by the 
	 * authenticating authority and is used as a seed in
	 * creating a hash from the secret.
	 * 
	 * @param challenge		the challenge
	 */
	public synchronized void setChallenge(byte[] challenge)
	{
		this.challenge = challenge.clone();
	}
	
	/**
	 * Return the value of the challenge.
	 * 
	 * The challenge is an array of bytes generated by the 
	 * authenticating authority and is used as a seed in
	 * creating a hash from the secret.
	 * 
	 * @return				the challenge
	 */
	public synchronized byte[] getChallenge()
	{
		return challenge.clone();
	}
	
	/**
	 * Returns the CHAP proof.
	 * 
	 * The proof is a hash of the <code>secret</code> and
	 * the <code>challenge</code>. 
	 *  
	 * @return			the proof
	 */
	public synchronized byte[] getProof()
	{
		if((challenge == null) || (secret == null))
		{
			throw new IllegalStateException();
		}
		
		if(proof == null)
		{
			proof = digest(challenge,secret);
		}
		return proof.clone();
	}
	
	/**
	 * Digest the <code>secret</code> and the <code>challenge</code>
	 * and return the resulting byte array.
	 * 
	 * @param challenge			The CHAP challenge
	 * @param secret			The secret
	 * @return					The hash of the <code>secret</code> and the <code>challenge</code>
	 */
	private byte[] digest(byte[] challenge,String secret)
	{
		MessageDigest digest = Digest.sha1();
		digest.update(challenge);
		digest.update(secret.getBytes());
		return digest.digest();
	}
}
